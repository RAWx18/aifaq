

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Private Data &mdash; Hyperledger Fabric Docs main documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=c3038dac" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=a8da1a53"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Read-Write set semantics" href="readwrite.html" />
    <link rel="prev" title="Peer channel-based event services" href="peer_event_services.html" /> 
<script async type="text/javascript" src="/_/static/javascript/readthedocs-addons.js"></script><meta name="readthedocs-project-slug" content="hyperledger-fabric" /><meta name="readthedocs-version-slug" content="release-2.5" /><meta name="readthedocs-resolver-filename" content="/private-data-arch.html" /><meta name="readthedocs-http-status" content="200" /></head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >


          
          
          <a href="index.html" class="icon icon-home">
            Hyperledger Fabric Docs
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

<br><img style="background-color: #fff; height: unset; width: unset;" alt="Hyperledger Fabric" src=_images/hyperledger_fabric_logo_color.png />
<br>
<a href="https://github.com/hyperledger/fabric"><img style="padding: 0px; margin: auto auto auto auto;" alt="GitHub" src="_static/images/github_button.png"/></a>
&nbsp;<a href="https://stackoverflow.com/questions/tagged/hyperledger-fabric"><img style="padding: 0px; margin: auto auto auto auto;" alt="StackOverflow" src="_static/images/stackoverflow_button.png"/></a>
&nbsp;<a href="https://discord.com/invite/hyperledger"><img style="padding: 0px; margin: auto auto auto auto;" alt="Discord" src="_static/images/discord_button.png"/></a>
&nbsp;<a href="https://www.youtube.com/playlist?list=PL0MZ85B_96CH7wvtrRzV7SvtRY0sI0DEg"><img style="padding: 0px; margin: auto auto auto auto;" alt="Youtube Channel" src="_static/images/youtube_button.png"/></a>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="whatis.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="whatsnew.html">What’s new in Hyperledger Fabric v2.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="whatsnew.html#release-notes">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="key_concepts.html">Key Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started - Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started_run_fabric.html">Getting Started - Run Fabric</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="deployment_guide_overview.html">Deploying a production network</a></li>
<li class="toctree-l1"><a class="reference internal" href="ops_guide.html">Operations Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="upgrade.html">Upgrading to the latest release</a></li>
<li class="toctree-l1"><a class="reference internal" href="command_ref.html">Commands Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="architecture.html">Architecture Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference external" href="http://hyperledger-fabric-ca.readthedocs.io/en/latest">Hyperledger Fabric CA's User Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="txflow.html">Transaction Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="gateway.html">Fabric Gateway</a></li>
<li class="toctree-l2"><a class="reference internal" href="discovery-overview.html">Service Discovery</a></li>
<li class="toctree-l2"><a class="reference internal" href="capability_requirements.html">Defining capability requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="channels.html">Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="couchdb_as_state_database.html">CouchDB as the State Database</a></li>
<li class="toctree-l2"><a class="reference internal" href="peer_event_services.html">Peer channel-based event services</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Private Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#private-data-collection-definition">Private data collection definition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implicit-private-data-collections">Implicit private data collections</a></li>
<li class="toctree-l3"><a class="reference internal" href="#private-data-dissemination">Private data dissemination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#referencing-collections-from-chaincode">Referencing collections from chaincode</a></li>
<li class="toctree-l3"><a class="reference internal" href="#referencing-implicit-collections-from-chaincode">Referencing implicit collections from chaincode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#how-to-pass-private-data-in-a-chaincode-proposal">How to pass private data in a chaincode proposal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#protecting-private-data-content">Protecting private data content</a></li>
<li class="toctree-l4"><a class="reference internal" href="#protecting-private-data-responses">Protecting private data responses</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-control-for-private-data">Access control for private data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#querying-private-data">Querying Private Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-indexes-with-collections">Using Indexes with collections</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#considerations-when-using-private-data">Considerations when using private data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#private-data-purging">Private data purging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#updating-a-collection-definition">Updating a collection definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#private-data-reconciliation">Private data reconciliation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="readwrite.html">Read-Write set semantics</a></li>
<li class="toctree-l2"><a class="reference internal" href="gossip.html">Gossip data dissemination protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance.html">Performance considerations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Fabric-FAQ.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributions Welcome!</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="questions.html">Still Have Questions?</a></li>
<li class="toctree-l1"><a class="reference internal" href="status.html">Status</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Hyperledger Fabric Docs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="architecture.html">Architecture Reference</a></li>
      <li class="breadcrumb-item active">Private Data</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/private-data-arch.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="private-data">
<h1>Private Data<a class="headerlink" href="#private-data" title="Link to this heading">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This topic assumes an understanding of the conceptual material in the
<a class="reference external" href="private-data/private-data.html">documentation on private data</a>.</p>
</div>
<section id="private-data-collection-definition">
<h2>Private data collection definition<a class="headerlink" href="#private-data-collection-definition" title="Link to this heading">¶</a></h2>
<p>A collection definition contains one or more collections, each having a policy
definition listing the organizations in the collection, as well as properties
used to control dissemination of private data at endorsement time and,
optionally, whether the data will be purged.</p>
<p>Beginning with the Fabric chaincode lifecycle introduced with Fabric v2.0, the
collection definition is part of the chaincode definition. The chaincode including
collection definition must be approved by the required channel members, and
then becomes effective when the chaincode definition is committed to the channel.
The collection definition that is approved must be identical for each of the required
channel members. When using the peer CLI to approve and commit the
chaincode definition, use the <code class="docutils literal notranslate"><span class="pre">--collections-config</span></code> flag to specify the path
to the collection definition file.</p>
<p>Collection definitions are composed of the following properties:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: Name of the collection.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The private data collection distribution policy defines which
organizations’ peers are allowed to retrieve and persist the collection data expressed using
the <code class="docutils literal notranslate"><span class="pre">Signature</span></code> policy syntax, with each member being included in an <code class="docutils literal notranslate"><span class="pre">OR</span></code>
signature policy list. To support read/write transactions, the private data
distribution policy must define a broader set of organizations than the
endorsement policy, as peers must have the private data in order to endorse
proposed transactions. For example, in a channel with ten organizations,
five of the organizations might be included in a private data collection
distribution policy, but the endorsement policy might call for any three
of the organizations in the channel to endorse a read/write transaction.
For write-only transactions, organizations that are not members of the
collection distribution policy but are included in the chaincode level
endorsement policy may endorse transactions that write to the private data
collection. If this is not desirable, utilize a collection level
<code class="docutils literal notranslate"><span class="pre">endorsementPolicy</span></code> to restrict the set of allowed endorsers to the private data
distribution policy members.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code>: Minimum number of peers (across authorized organizations)
that each endorsing peer must successfully disseminate private data to before the
peer signs the endorsement and returns the proposal response back to the client.
Requiring dissemination as a condition of endorsement will ensure that private data
is available in the network even if the endorsing peer(s) become unavailable. When
<code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code> is <code class="docutils literal notranslate"><span class="pre">0</span></code>, it means that no distribution is <strong>required</strong>,
but there may be some distribution if <code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code> is greater than zero. A
<code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code> of <code class="docutils literal notranslate"><span class="pre">0</span></code> would typically not be recommended, as it could
lead to loss of private data in the network if the endorsing peer(s) becomes unavailable.
Typically you would want to require at least some distribution of the private
data at endorsement time to ensure redundancy of the private data on multiple
peers in the network.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code>: For data redundancy purposes, the maximum number of other
peers (across authorized organizations) that each endorsing peer will attempt
to distribute the private data to. If an endorsing peer becomes unavailable between
endorsement time and commit time, other peers that are collection members but who
did not yet receive the private data at endorsement time, will be able to pull
the private data from peers the private data was disseminated to. If this value
is set to <code class="docutils literal notranslate"><span class="pre">0</span></code>, the private data is not disseminated at endorsement time,
forcing private data pulls against endorsing peers on all authorized peers at
commit time.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">blockToLive</span></code>: Represents how long the data should live on the private
database in terms of blocks. The data will live for this specified number of
blocks on the private database and after that it will get purged, making this
data obsolete from the network so that it cannot be queried from chaincode,
and cannot be made available to requesting peers. To keep private data
indefinitely, that is, to never purge private data, set the <code class="docutils literal notranslate"><span class="pre">blockToLive</span></code>
property to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memberOnlyRead</span></code>: a value of <code class="docutils literal notranslate"><span class="pre">true</span></code> indicates that peers automatically
enforce that only clients belonging to one of the collection member organizations
are allowed read access to private data. If a client from a non-member org
attempts to execute a chaincode function that performs a read of a private data key,
the chaincode invocation is terminated with an error. Utilize a value of
<code class="docutils literal notranslate"><span class="pre">false</span></code> if you would like to encode more granular access control within
individual chaincode functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memberOnlyWrite</span></code>: a value of <code class="docutils literal notranslate"><span class="pre">true</span></code> indicates that peers automatically
enforce that only clients belonging to one of the collection member organizations
are allowed to write private data from chaincode. If a client from a non-member org
attempts to execute a chaincode function that performs a write on a private data key,
the chaincode invocation is terminated with an error. Utilize a value of
<code class="docutils literal notranslate"><span class="pre">false</span></code> if you would like to encode more granular access control within
individual chaincode functions, for example you may want certain clients
from non-member organization to be able to create private data in a certain
collection.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">endorsementPolicy</span></code>: An optional endorsement policy to utilize for the
collection that overrides the chaincode level endorsement policy. A
collection level endorsement policy may be specified in the form of a
<code class="docutils literal notranslate"><span class="pre">signaturePolicy</span></code> or may be a <code class="docutils literal notranslate"><span class="pre">channelConfigPolicy</span></code> reference to
an existing policy from the channel configuration. The <code class="docutils literal notranslate"><span class="pre">endorsementPolicy</span></code>
may be the same as the collection distribution <code class="docutils literal notranslate"><span class="pre">policy</span></code>, or may require
fewer or additional organization peers.</p></li>
</ul>
<p>Here is a sample collection definition JSON file, containing an array of two
collection definitions:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>
<span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="s2">&quot;name&quot;</span>:<span class="w"> </span><span class="s2">&quot;collectionMarbles&quot;</span>,
<span class="w">    </span><span class="s2">&quot;policy&quot;</span>:<span class="w"> </span><span class="s2">&quot;OR(&#39;Org1MSP.member&#39;, &#39;Org2MSP.member&#39;)&quot;</span>,
<span class="w">    </span><span class="s2">&quot;requiredPeerCount&quot;</span>:<span class="w"> </span><span class="m">0</span>,
<span class="w">    </span><span class="s2">&quot;maxPeerCount&quot;</span>:<span class="w"> </span><span class="m">3</span>,
<span class="w">    </span><span class="s2">&quot;blockToLive&quot;</span>:1000000,
<span class="w">    </span><span class="s2">&quot;memberOnlyRead&quot;</span>:<span class="w"> </span>true,
<span class="w">    </span><span class="s2">&quot;memberOnlyWrite&quot;</span>:<span class="w"> </span><span class="nb">true</span>
<span class="w"> </span><span class="o">}</span>,
<span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="s2">&quot;name&quot;</span>:<span class="w"> </span><span class="s2">&quot;collectionMarblePrivateDetails&quot;</span>,
<span class="w">    </span><span class="s2">&quot;policy&quot;</span>:<span class="w"> </span><span class="s2">&quot;OR(&#39;Org1MSP.member&#39;)&quot;</span>,
<span class="w">    </span><span class="s2">&quot;requiredPeerCount&quot;</span>:<span class="w"> </span><span class="m">0</span>,
<span class="w">    </span><span class="s2">&quot;maxPeerCount&quot;</span>:<span class="w"> </span><span class="m">3</span>,
<span class="w">    </span><span class="s2">&quot;blockToLive&quot;</span>:3,
<span class="w">    </span><span class="s2">&quot;memberOnlyRead&quot;</span>:<span class="w"> </span>true,
<span class="w">    </span><span class="s2">&quot;memberOnlyWrite&quot;</span>:true,
<span class="w">    </span><span class="s2">&quot;endorsementPolicy&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">      </span><span class="s2">&quot;signaturePolicy&quot;</span>:<span class="w"> </span><span class="s2">&quot;OR(&#39;Org1MSP.member&#39;)&quot;</span>
<span class="w">    </span><span class="o">}</span>
<span class="w"> </span><span class="o">}</span>
<span class="o">]</span>
</pre></div>
</div>
<p>This example uses the organizations from the Fabric test network, <code class="docutils literal notranslate"><span class="pre">Org1</span></code> and
<code class="docutils literal notranslate"><span class="pre">Org2</span></code>. The policy in the  <code class="docutils literal notranslate"><span class="pre">collectionMarbles</span></code> definition authorizes both
organizations to the private data. This is a typical configuration when the
chaincode data needs to remain private from the ordering service nodes. However,
the policy in the <code class="docutils literal notranslate"><span class="pre">collectionMarblePrivateDetails</span></code> definition restricts access
to a subset of organizations in the channel (in this case <code class="docutils literal notranslate"><span class="pre">Org1</span></code> ). Additionally,
writing to this collection requires endorsement from an <code class="docutils literal notranslate"><span class="pre">Org1</span></code> peer, even
though the chaincode level endorsement policy may require endorsement from
<code class="docutils literal notranslate"><span class="pre">Org1</span></code> or <code class="docutils literal notranslate"><span class="pre">Org2</span></code>. And since “memberOnlyWrite” is true, only clients from
<code class="docutils literal notranslate"><span class="pre">Org1</span></code> may invoke chaincode that writes to the private data collection.
In this way you can control which organizations are entrusted to write to certain
private data collections.</p>
</section>
<section id="implicit-private-data-collections">
<h2>Implicit private data collections<a class="headerlink" href="#implicit-private-data-collections" title="Link to this heading">¶</a></h2>
<p>In addition to explicitly defined private data collections,
every chaincode has an implicit private data namespace reserved for organization-specific
private data. These implicit organization-specific private data collections can
be used to store an individual organization’s private data, and do not need to
be defined explicitly.</p>
<p>The private data dissemination policy and endorsement policy for implicit
organization-specific collections is the respective organization itself.
The implication is that if data exists in an implicit private data collection,
it was endorsed by the respective organization. Implicit private data collections
can therefore be used by an organization to record their agreement or vote
for some fact, which is a useful pattern to leverage in multi-party business
processes implemented in chaincode since other organizations can check
the on-chain hash to verify the organization’s record. Private data
can also be shared or transferred to an implicit collection of another organization,
making implicit collections a useful pattern to leverage in chaincode
applications, without the need to explicitly manage collection definitions.</p>
<p>Since implicit private data collections are not explicitly defined,
it is not possible to set the additional collection properties. Specifically,
<code class="docutils literal notranslate"><span class="pre">memberOnlyRead</span></code> and <code class="docutils literal notranslate"><span class="pre">memberOnlyWrite</span></code> are not available,
meaning that access control for clients reading data from or writing data to
an implicit private data collection must be encoded in the <a class="reference external" href="chaincode4ade.html#chaincode-access-control">chaincode logic</a>
on the organization’s peer.
Furthermore, <code class="docutils literal notranslate"><span class="pre">blockToLive</span></code> is not available, meaning that private data is never automatically purged.</p>
<p>The properties <code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code> and <code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code> can however be set in the peer’s core.yaml
(<code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.implicitCollectionDisseminationPolicy.requiredPeerCount</span></code> and
<code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.implicitCollectionDisseminationPolicy.maxPeerCount</span></code>). An organization
can set these properties based on the number of peers that they deploy, as described
in the next section.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since implicit private data collections are not explicitly defined,
it is not possible to associate CouchDB indexes with them. Utilize
key-based queries and key-range queries rather than JSON queries.</p>
</div>
</section>
<section id="private-data-dissemination">
<h2>Private data dissemination<a class="headerlink" href="#private-data-dissemination" title="Link to this heading">¶</a></h2>
<p>Since private data is not included in the transactions that get submitted to
the ordering service, and therefore not included in the blocks that get distributed
to all peers in a channel, the endorsing peer plays an important role in
disseminating private data to other peers of authorized organizations. This ensures
the availability of private data in the channel’s collection, even if endorsing
peers become unavailable after their endorsement. To assist with this dissemination,
the  <code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code> and <code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code> properties
control the degree of dissemination at endorsement time.</p>
<p>If the endorsing peer cannot successfully disseminate the private data to at least
the <code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code>, it will return an error back to the client. The endorsing
peer will attempt to disseminate the private data to peers of different organizations,
in an effort to ensure that each authorized organization has a copy of the private
data. Since transactions are not committed at chaincode execution time, the endorsing
peer and recipient peers store a copy of the private data in a local <code class="docutils literal notranslate"><span class="pre">transient</span> <span class="pre">store</span></code>
alongside their blockchain until the transaction is committed.</p>
<p>When authorized peers do not have a copy of the private data in their transient
data store at commit time (either because they were not an endorsing peer or because
they did not receive the private data via dissemination at endorsement time),
they will attempt to pull the private data from another authorized
peer, <em>for a configurable amount of time</em> based on the peer property
<code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.pullRetryThreshold</span></code> in the peer configuration <code class="docutils literal notranslate"><span class="pre">core.yaml</span></code>
file.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The peers being asked for private data will only return the private data
if the requesting peer is a member of the collection as defined by the
private data dissemination policy.</p>
</div>
<p>Considerations when using <code class="docutils literal notranslate"><span class="pre">pullRetryThreshold</span></code>:</p>
<ul class="simple">
<li><p>If the requesting peer is able to retrieve the private data within the
<code class="docutils literal notranslate"><span class="pre">pullRetryThreshold</span></code>, it will commit the transaction to its ledger
(including the private data hash), and store the private data in its
state database, logically separated from other channel state data.</p></li>
<li><p>If the requesting peer is not able to retrieve the private data within
the <code class="docutils literal notranslate"><span class="pre">pullRetryThreshold</span></code>, it will commit the transaction to it’s blockchain
(including the private data hash), without the private data.</p></li>
<li><p>If the peer was entitled to the private data but it is missing, then
that peer will not be able to endorse future transactions that reference
the missing private data - a chaincode query for a key that is missing will
be detected (based on the presence of the key’s hash in the state database),
and the chaincode will receive an error.</p></li>
</ul>
<p>Therefore, it is important to set the <code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code> and <code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code>
properties large enough to ensure the availability of private data in your
channel. For example, if each of the endorsing peers become unavailable
before the transaction commits, the <code class="docutils literal notranslate"><span class="pre">requiredPeerCount</span></code> and <code class="docutils literal notranslate"><span class="pre">maxPeerCount</span></code>
properties will have ensured the private data is available on other peers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For collections to work, it is important to have cross organizational
gossip configured correctly. Refer to our documentation on <a class="reference internal" href="gossip.html"><span class="doc">Gossip data dissemination protocol</span></a>,
paying particular attention to the “anchor peers” and “external endpoint”
configuration.</p>
</div>
</section>
<section id="referencing-collections-from-chaincode">
<h2>Referencing collections from chaincode<a class="headerlink" href="#referencing-collections-from-chaincode" title="Link to this heading">¶</a></h2>
<p>A set of <a class="reference external" href="https://godoc.org/github.com/hyperledger/fabric-chaincode-go/shim">shim APIs</a>
are available for setting and retrieving private data.</p>
<p>The same chaincode data operations can be applied to channel state data and
private data, but in the case of private data, a collection name is specified
along with the data in the chaincode APIs, for example
<code class="docutils literal notranslate"><span class="pre">PutPrivateData(collection,key,value)</span></code> and <code class="docutils literal notranslate"><span class="pre">GetPrivateData(collection,key)</span></code>.</p>
<p>A single chaincode can reference multiple collections.</p>
</section>
<section id="referencing-implicit-collections-from-chaincode">
<h2>Referencing implicit collections from chaincode<a class="headerlink" href="#referencing-implicit-collections-from-chaincode" title="Link to this heading">¶</a></h2>
<p>Starting in v2.0, an implicit private data collection can be used for each
organization in a channel, so that you don’t have to define collections if you’d
like to utilize per-organization collections. Each org-specific implicit collection
has a distribution policy and endorsement policy of the matching organization.
You can therefore utilize implicit collections for use cases where you’d like
to ensure that a specific organization has written to a collection key namespace.
The v2.0 chaincode lifecycle uses implicit collections to track which organizations
have approved a chaincode definition. Similarly, you can use implicit collections
in application chaincode to track which organizations have approved or voted
for some change in state.</p>
<p>To write and read an implicit private data collection key, in the <code class="docutils literal notranslate"><span class="pre">PutPrivateData</span></code>
and <code class="docutils literal notranslate"><span class="pre">GetPrivateData</span></code> chaincode APIs, specify the collection parameter as
<code class="docutils literal notranslate"><span class="pre">&quot;_implicit_org_&lt;MSPID&gt;&quot;</span></code>, for example <code class="docutils literal notranslate"><span class="pre">&quot;_implicit_org_Org1MSP&quot;</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Application defined collection names are not allowed to start with an underscore,
therefore there is no chance for an implicit collection name to collide
with an application defined collection name.</p>
</div>
<section id="how-to-pass-private-data-in-a-chaincode-proposal">
<h3>How to pass private data in a chaincode proposal<a class="headerlink" href="#how-to-pass-private-data-in-a-chaincode-proposal" title="Link to this heading">¶</a></h3>
<p>Since the chaincode proposal gets stored on the blockchain, it is also important
not to include private data in the main part of the chaincode proposal. A special
field in the chaincode proposal called the <code class="docutils literal notranslate"><span class="pre">transient</span></code> field can be used to pass
private data from the client (or data that chaincode will use to generate private
data), to chaincode invocation on the peer.  The chaincode can retrieve the
<code class="docutils literal notranslate"><span class="pre">transient</span></code> field by calling the <a class="reference external" href="https://godoc.org/github.com/hyperledger/fabric-chaincode-go/shim#ChaincodeStub.GetTransient">GetTransient() API</a>.
This <code class="docutils literal notranslate"><span class="pre">transient</span></code> field gets excluded from the channel transaction.</p>
</section>
<section id="protecting-private-data-content">
<h3>Protecting private data content<a class="headerlink" href="#protecting-private-data-content" title="Link to this heading">¶</a></h3>
<p>If the private data is relatively simple and predictable (e.g. transaction dollar
amount), channel members who are not authorized to the private data collection
could try to guess the content of the private data via brute force hashing of
the domain space, in hopes of finding a match with the private data hash on the
chain. Private data that is predictable should therefore include a random “salt”
that is concatenated with the private data key and included in the private data
value, so that a matching hash cannot realistically be found via brute force.
The random “salt” can be generated at the client side (e.g. by sampling a secure
pseudo-random source) and then passed along with the private data in the transient
field at the time of chaincode invocation.</p>
</section>
<section id="protecting-private-data-responses">
<h3>Protecting private data responses<a class="headerlink" href="#protecting-private-data-responses" title="Link to this heading">¶</a></h3>
<p>Chaincode can return any data to a client application in the proposal response payload field.
For read-only chaincode functions that query private data and which will not get submitted as transactions to the ordering service,
private data may be returned in the proposal response payload field to the requesting client.
For chaincode functions that propose private data writes however, take care not to include
private data in the proposal response payload field, since this field will get
included in the transaction which all channel members can access.</p>
</section>
<section id="access-control-for-private-data">
<h3>Access control for private data<a class="headerlink" href="#access-control-for-private-data" title="Link to this heading">¶</a></h3>
<p>Until version 1.3, access control to private data based on collection membership
was enforced for peers only. Access control based on the organization of the
chaincode proposal submitter was required to be encoded in chaincode logic.
Collection configuration options <code class="docutils literal notranslate"><span class="pre">memberOnlyRead</span></code> (since version v1.4) and
<code class="docutils literal notranslate"><span class="pre">memberOnlyWrite</span></code> (since version v2.0) can automatically enforce that the chaincode
proposal submitter must be from a collection member in order to read or write
private data keys. For more information about collection
configuration definitions and how to set them, refer back to the
<a class="reference internal" href="#private-data-collection-definition">Private data collection definition</a>  section of this topic.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you would like more granular access control, you can set
<code class="docutils literal notranslate"><span class="pre">memberOnlyRead</span></code> and <code class="docutils literal notranslate"><span class="pre">memberOnlyWrite</span></code> to false (implicit collections always
behave as if <code class="docutils literal notranslate"><span class="pre">memberOnlyRead</span></code> and <code class="docutils literal notranslate"><span class="pre">memberOnlyWrite</span></code> are false). You can then apply your
own <a class="reference external" href="chaincode4ade.html#chaincode-access-control">access control logic in chaincode</a>,
for example by calling the GetCreator() chaincode API or using the client identity
<a class="reference external" href="https://godoc.org/github.com/hyperledger/fabric-chaincode-go/shim#ChaincodeStub.GetCreator">chaincode library</a> .</p>
</div>
</section>
<section id="querying-private-data">
<h3>Querying Private Data<a class="headerlink" href="#querying-private-data" title="Link to this heading">¶</a></h3>
<p>Private data collection can be queried just like normal channel data, using
shim APIs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GetPrivateDataByRange(collection,</span> <span class="pre">startKey,</span> <span class="pre">endKey</span> <span class="pre">string)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GetPrivateDataByPartialCompositeKey(collection,</span> <span class="pre">objectType</span> <span class="pre">string,</span> <span class="pre">keys</span> <span class="pre">[]string)</span></code></p></li>
</ul>
<p>And if using explicit private data collections and CouchDB state database,
JSON content queries can be passed using the shim API:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GetPrivateDataQueryResult(collection,</span> <span class="pre">query</span> <span class="pre">string)</span></code></p></li>
</ul>
<p>Limitations:</p>
<ul class="simple">
<li><p>Clients that call chaincode that executes key range queries or JSON queries should be aware
that they may receive a subset of the result set, if the peer they query has missing
private data, based on the explanation in Private Data Dissemination section
above.  Clients can query multiple peers and compare the results to
determine if a peer may be missing some of the result set.</p></li>
<li><p>Chaincode that executes key range queries or JSON queries and updates data in a single
transaction is not supported, as the query results cannot be validated on the peers
that don’t have access to the private data, or on peers that are missing the
private data that they have access to. If a chaincode invocation both queries
and updates private data, the proposal request will return an error. If your application
can tolerate result set changes between chaincode execution and validation/commit time,
then you could call one chaincode function to perform the query, and then call a second
chaincode function to make the updates. Note that calls to GetPrivateData() to retrieve
individual keys can be made in the same transaction as PutPrivateData() calls, since
all peers can validate key reads based on the hashed key version.</p></li>
<li><p>Since implicit private data collections are not explicitly defined,
it is not possible to associate CouchDB indexes with them.
It is therefore not recommended to utilize JSON queries with implicit private data collections.</p></li>
</ul>
</section>
<section id="using-indexes-with-collections">
<h3>Using Indexes with collections<a class="headerlink" href="#using-indexes-with-collections" title="Link to this heading">¶</a></h3>
<p>The topic <a class="reference internal" href="couchdb_as_state_database.html"><span class="doc">CouchDB as the State Database</span></a> describes indexes that can be
applied to the channel’s state database to enable JSON content queries, by
packaging indexes in a <code class="docutils literal notranslate"><span class="pre">META-INF/statedb/couchdb/indexes</span></code> directory at chaincode
installation time.  Similarly, indexes can also be applied to private data
collections that are explicitly defined, by packaging indexes in a <code class="docutils literal notranslate"><span class="pre">META-INF/statedb/couchdb/collections/&lt;collection_name&gt;/indexes</span></code>
directory. An example index is available <a class="reference external" href="https://github.com/hyperledger/fabric-samples/blob/main/chaincode/marbles02_private/go/META-INF/statedb/couchdb/collections/collectionMarbles/indexes/indexOwner.json">here</a>.</p>
</section>
</section>
<section id="considerations-when-using-private-data">
<h2>Considerations when using private data<a class="headerlink" href="#considerations-when-using-private-data" title="Link to this heading">¶</a></h2>
<section id="private-data-purging">
<h3>Private data purging<a class="headerlink" href="#private-data-purging" title="Link to this heading">¶</a></h3>
<p>Private data can be purged from peers so that it is not available for chaincode queries, not available in block events, and not available for other peers requesting the private data.</p>
<p><strong>Purging private data in chaincode</strong></p>
<p>Private data can be deleted from state just like regular state data so that it is not available for query in chaincode for future transactions.
However, when private data is simply deleted from state, the history of the private data remains in the peer’s private database so that it can be returned in block events and returned to other peers that are catching up to the current block height.
If you need to completely remove the private data from all peers that have access to it, use the chaincode API <code class="docutils literal notranslate"><span class="pre">PurgePrivateData</span></code> instead of the <code class="docutils literal notranslate"><span class="pre">DelPrivateData</span></code> API.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PurgePrivateData</span></code> chaincode API is available starting in Fabric v2.5. To ensure that all peers are at v2.5 or later, the application capability <code class="docutils literal notranslate"><span class="pre">V2_5</span></code> or higher must be set in the channel’s configuration before using the feature.</p>
<p>Private data is purged from a peer’s private database at the time of block commit.
For more efficiency, the purge requests can be processed at certain block intervals based on the <code class="docutils literal notranslate"><span class="pre">ledger.pvtdataStore.purgeInterval</span></code> setting in the peer <code class="docutils literal notranslate"><span class="pre">core.yaml</span></code> configuration, with a default of purging every 100 blocks.
To process purge requests every block set <code class="docutils literal notranslate"><span class="pre">ledger.pvtdataStore.purgeInterval</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code>.
Regardless of the <code class="docutils literal notranslate"><span class="pre">purgeInterval</span></code> setting, the associated private data state will be deleted from the state database upon every block commit so that it is not available for subsequent transaction endorsements or queries.
Similarly, any purged private data will not be returned in block events or returned to other peers requesting it.
Only the historical values in the private database will remain until the next <code class="docutils literal notranslate"><span class="pre">purgeInterval</span></code>.</p>
<p><strong>Purging private data automatically</strong></p>
<p>Private data in explicitly defined private data collections can be periodically purged from peers if it has not been modified for a configurable number of blocks.
For more details, see the <code class="docutils literal notranslate"><span class="pre">blockToLive</span></code> collection definition property above.</p>
<p><strong>Purging uncommitted private data</strong></p>
<p>Recall that prior to commit, peers store private data in a local
transient data store. This data automatically gets purged when the transaction
commits.  But if a transaction was never submitted to the channel and
therefore never committed, the private data would remain in each peer’s
transient store.  This data is purged from the transient store after a
configurable number blocks by using the peer’s
<code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.transientstoreMaxBlockRetention</span></code> property in the peer
<code class="docutils literal notranslate"><span class="pre">core.yaml</span></code> file.</p>
</section>
<section id="updating-a-collection-definition">
<h3>Updating a collection definition<a class="headerlink" href="#updating-a-collection-definition" title="Link to this heading">¶</a></h3>
<p>To update a collection definition or add a new collection, you can update
the chaincode definition and pass the new collection configuration
in the chaincode approve and commit transactions, for example using the <code class="docutils literal notranslate"><span class="pre">--collections-config</span></code>
flag if using the CLI. If a collection configuration is specified when updating
the chaincode definition, a definition for each of the existing collections must be
included.</p>
<p>When updating a chaincode definition, you can add new private data collections,
and update existing private data collections, for example to add new
members to an existing collection or change one of the collection definition
properties. Note that you cannot update the collection name or the
blockToLive property, since a consistent blockToLive is required
regardless of a peer’s block height.</p>
<p>Collection updates becomes effective when a peer commits the block with the updated
chaincode definition. Note that collections cannot be
deleted, as there may be prior private data hashes on the channel’s blockchain
that cannot be removed.</p>
</section>
<section id="private-data-reconciliation">
<h3>Private data reconciliation<a class="headerlink" href="#private-data-reconciliation" title="Link to this heading">¶</a></h3>
<p>Starting in v1.4, peers of organizations that are added to an existing collection
will automatically fetch private data that was committed to the collection before
they joined the collection.</p>
<p>This private data “reconciliation” also applies to peers that
were entitled to receive private data but did not yet receive it — because of
a network failure, for example — by keeping track of private data that was “missing”
at the time of block commit.</p>
<p>Private data reconciliation occurs periodically based on the
<code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.reconciliationEnabled</span></code> and <code class="docutils literal notranslate"><span class="pre">peer.gossip.pvtData.reconcileSleepInterval</span></code>
properties in core.yaml. The peer will periodically attempt to fetch the private
data from other collection member peers that are expected to have it.</p>
<p>Note that this private data reconciliation feature only works on peers running
v1.4 or later of Fabric.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="readwrite.html" class="btn btn-neutral float-right" title="Read-Write set semantics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="peer_event_services.html" class="btn btn-neutral" title="Peer channel-based event services" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Hyperledger 2020-2023.
    <br>
      <br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>